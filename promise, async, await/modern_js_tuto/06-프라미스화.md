콜백을 받는 함수를 프라미스를 반환하는 함수로 바꾸는 것을 '프라미스화(promsiification)'라고 한다

기능을 구현 하다 보면 콜백보다는 프라미스가 더 편리하기 때문에 콜백 기반 함수와 라이브러리를 프라미스를 반환하는 함수로 바꾸는 게 좋은 경우가 종종 생길 것

```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`${src}를 불러오는 도중에 에러가 발생함`));

  document.head.append(script);
}

// 사용법:
// loadScript('path/script.js', (err, script) => {...})
```
`loadScript(src, callback)`를 이제 프라미스화해봅시다. 새로운 함수 `loadScriptPromise(src)`는 `loadScript`와 동일하게 동작하지만 `callback`을 제외한 `src`만 인수로 받아야 하고, 프라미스를 반환해야 한다

```js
let loadScriptPromise = function(src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err)
      else resolve(script);
    });
  })
}

// 사용법:
// loadScriptPromise('path/script.js').then(...)
```

헬퍼 함수를 만들어 보자
```js
function promisify(f) {
  return function (...args) { // 래퍼 함수를 반환함
    return new Promise((resolve, reject) => {
      function callback(err, result) { // f에 사용할 커스텀 콜백
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      }

      args.push(callback); // 위에서 만든 커스텀 콜백을 함수 f의 인수 끝에 추가합니다.

      f.call(this, ...args); // 기존 함수를 호출합니다.
    });
  };
};

// 사용법:
let loadScriptPromise = promisify(loadScript);
loadScriptPromise(...).then(...);
```

위 예시는 프라미스화 할 함수가 인수가 두개((err, result))인 콜백을 받을 것이라 가정하고 작성됨

두 개를 초솨하는 인수를 가진 콜백, `callback(err, res1, res2, ...)`을 받는 다면?

```js
// 콜백의 성공 결과를 담은 배열을 얻게 해주는 promisify(f, true)
function promisify(f, manyArgs = false) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(err, ...results) { // f에 사용할 커스텀 콜백
        if (err) {
          reject(err);
        } else {
          // manyArgs가 구체적으로 명시되었다면, 콜백의 성공 케이스와 함께 이행 상태가 됩니다.
          resolve(manyArgs ? results : results[0]);
        }
      }

      args.push(callback);

      f.call(this, ...args);
    });
  };
};

// 사용법:
f = promisify(f, true);
f(...).then(arrayOfResults => ..., err => ...)
```
`callback(result)`같이 `err`이 없는 형태나 지금까지 언급하지 않은 형태의 이색적인 콜백도 있을 수 있는데, 이런 경우엔 헬퍼 함수를 사용하지 않고 직접 프라미스화 하면 된다

본 챕터에서 설명한 헬퍼 함수보다 더 유용한 형태의 프라미스화를 도와주는 함수를 제공하는 모듈도 많습니다. [es6-promisify](https://github.com/digitaldesignlabs/es6-promisify)가 대표적인 예입니다. Node.js에선 내장 함수 `util.promisify`를 사용해 프라미스화를 할 수 있다

>[!CAUTION]  
>프라미스화는 곧 배우게 될 `async/await`와 함께 사용하면 더 좋습니다. 다만, 콜백을 완전히 대체하지는 못한다는 사실을 기억해 두시기 바랍니다.
> 
> 프라미스는 하나의 결과만 가질 수 있지만, 콜백은 여러 번 호출할 수 있기 때문입니다.
> 
> 따라서 프라미스화는 콜백을 단 한 번 호출하는 함수에만 적용하시기 바랍니다. 프라미스화한 함수의 콜백을 여러 번 호출해도, 두 번째부터는 무시됩니다.

보충 설명
- 한 번의 결과만 필요한 경우 (파일 읽기, DB 쿼리, HTTP 요청 등) → 프라미스 적합
```Js
// 콜백 방식
function queryDb(query, callback) {
    db.execute(query, (err, result) => {
        if (err) callback(err);
        else callback(null, result);
    });
}

// 프라미스로 변환 (적절한 사용)
function queryDbPromise(query) {
    return new Promise((resolve, reject) => {
        db.execute(query, (err, result) => {
            if (err) reject(err);
            else resolve(result);
        });
    });
}

// 사용
queryDbPromise("SELECT * FROM users")
    .then(result => console.log('조회 결과:', result))
    .catch(err => console.error('에러:', err));
```
- 지속적인 이벤트 처리가 필요한 경우 (타이머, 웹소켓, 이벤트 리스너 등) → 콜백 사용이 적합

```js
// 웹소켓 이벤트 리스너 - 콜백 방식 (정상)
const ws = new WebSocket('ws://example.com');
ws.onmessage = (event) => {
    console.log('메시지 수신:', event.data);
};

// 웹소켓을 프라미스로 변환 시도 (부적절)
function websocketPromise() {
    return new Promise((resolve) => {
        const ws = new WebSocket('ws://example.com');
        ws.onmessage = (event) => {
            resolve(event.data); // 첫 번째 메시지만 처리되고 이후 메시지는 무시됨!
        };
    });
}

websocketPromise()
    .then(data => console.log('메시지 수신:', data));
// 첫 번째 메시지만 처리되고 이후의 모든 메시지는 무시됨
```

then 체이닝으로도 불가? ㅇㅇ
```js
// then 체이닝을 시도한 경우
function websocketPromise() {
    return new Promise((resolve) => {
        const ws = new WebSocket('ws://example.com');
        ws.onmessage = (event) => {
            resolve(event.data);
        };
    });
}

websocketPromise()
    .then(data => {
        console.log('첫 번째 메시지:', data);
        return websocketPromise(); // 새로운 프라미스 반환
    })
    .then(data => {
        console.log('두 번째 메시지:', data);
        return websocketPromise(); // 새로운 프라미스 반환
    })
    .then(data => {
        console.log('세 번째 메시지:', data);
    });
```
then에서 새로운 WebSocket 연결을 생성하게 됨
실제로는 연속된 메시지를 받는 것이 아니라, 매번 새로운 연결을 맺고 첫 메시지만 받는 것
원래 의도한 "같은 연결에서 오는 연속적인 메시지 처리"가 불가능

연결 과정은 프라미스로 처리 연결 이후의 메시지는 이벤트 리스너로 처리하는게 좋음
```js
function connectWebSocket(url) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(url);
        
        ws.onopen = () => {
            console.log('연결 성공!');
            resolve(ws); // 연결된 웹소켓 객체를 반환
        };
        
        ws.onerror = (error) => {
            console.log('연결 실패!');
            reject(error);
        };
    });
}

// 사용 예시
connectWebSocket('ws://example.com')
    .then(ws => {
        // 연결된 웹소켓으로 메시지 처리
        ws.onmessage = (event) => {
            console.log('메시지 수신:', event.data);
        };
        
        // 메시지 전송
        ws.send('Hello!');
    })
    .catch(error => {
        console.error('웹소켓 연결 에러:', error);
    });
```


나만의 언어로 비유:
>콜백으로 된 것을 프라미스화 할 수 있다.
>전부 다 가능 한 것은 아니고 어울리는 곳이 있음
>하나의 결과만 가지기 때문에

>주문벨 시스템으로 바꾼다고 해보자 전부 가능 할까?
>주문벨이 좋아서 전부 주문벨로 바꿀 수 있을까?
>가능한 곳도 있고 아닐 수도 있음
>판단의 근거는 한 번의 결과만 필요한지 계속 요청하는지
>예를 들어서 주문벨에서 음식이 준비되면 음식을 받는것은 가능
>하지만 호출벨의 경우는? 매번 고객이 여러 번 부를 수 있어야 하므로 불가능 하다
>